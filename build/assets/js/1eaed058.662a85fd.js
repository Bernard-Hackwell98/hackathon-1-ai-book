"use strict";(globalThis.webpackChunkai_book_ros2_module=globalThis.webpackChunkai_book_ros2_module||[]).push([[728],{2066(e,t,r){r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=r(8168),a=(r(6540),r(5680));const i={sidebar_position:2,title:"Chapter 1 - Introduction to ROS 2 for Humanoid Robotics"},o="Chapter 1: Introduction to ROS 2 for Humanoid Robotics",s={unversionedId:"modules/ros2-humanoid/chapter-1-intro/index",id:"modules/ros2-humanoid/chapter-1-intro/index",title:"Chapter 1 - Introduction to ROS 2 for Humanoid Robotics",description:"Learning Objectives",source:"@site/docs/modules/ros2-humanoid/chapter-1-intro/index.md",sourceDirName:"modules/ros2-humanoid/chapter-1-intro",slug:"/modules/ros2-humanoid/chapter-1-intro/",permalink:"/hackathon-1-ai-book/modules/ros2-humanoid/chapter-1-intro/",draft:!1,editUrl:"https://github.com/bernard-hackwell98/hackathon-1-ai-book/tree/main/docs/modules/ros2-humanoid/chapter-1-intro/index.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Chapter 1 - Introduction to ROS 2 for Humanoid Robotics"},sidebar:"ros2HumanoidSidebar",previous:{title:"Introduction to ROS 2 for Humanoid Robotics",permalink:"/hackathon-1-ai-book/modules/ros2-humanoid/intro"},next:{title:"Chapter 2 - ROS 2 Communication Primitives",permalink:"/hackathon-1-ai-book/modules/ros2-humanoid/chapter-2-communication/"}},l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"What is ROS 2 and Why is it Essential for Physical AI?",id:"what-is-ros-2-and-why-is-it-essential-for-physical-ai",level:2},{value:"ROS 2 Architecture Overview (nodes, executors, DDS)",id:"ros-2-architecture-overview-nodes-executors-dds",level:2},{value:"Nodes",id:"nodes",level:3},{value:"Executors",id:"executors",level:3},{value:"DDS (Data Distribution Service)",id:"dds-data-distribution-service",level:3},{value:"Why ROS 2 over ROS 1 for Real-time Humanoid Systems?",id:"why-ros-2-over-ros-1-for-real-time-humanoid-systems",level:2},{value:"Improved Real-time Performance",id:"improved-real-time-performance",level:3},{value:"Enhanced Security",id:"enhanced-security",level:3},{value:"Better Architecture",id:"better-architecture",level:3},{value:"Improved Middleware Support",id:"improved-middleware-support",level:3},{value:"How Middleware Enables Embodied Intelligence",id:"how-middleware-enables-embodied-intelligence",level:2},{value:"The Nervous System Analogy",id:"the-nervous-system-analogy",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Content Validation",id:"content-validation",level:2}],m={toc:c};function d({components:e,...t}){return(0,a.yg)("wrapper",(0,n.A)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"chapter-1-introduction-to-ros-2-for-humanoid-robotics"},"Chapter 1: Introduction to ROS 2 for Humanoid Robotics"),(0,a.yg)("h2",{id:"learning-objectives"},"Learning Objectives"),(0,a.yg)("p",null,"After completing this chapter, students will be able to:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Explain what ROS 2 is and why it is essential for Physical AI"),(0,a.yg)("li",{parentName:"ul"},"Describe the core components of ROS 2 architecture (nodes, executors, DDS)"),(0,a.yg)("li",{parentName:"ul"},"Articulate why ROS 2 is preferred over ROS 1 for real-time humanoid systems"),(0,a.yg)("li",{parentName:"ul"},"Understand how middleware enables embodied intelligence")),(0,a.yg)("h2",{id:"what-is-ros-2-and-why-is-it-essential-for-physical-ai"},"What is ROS 2 and Why is it Essential for Physical AI?"),(0,a.yg)("p",null,"ROS 2 (Robot Operating System 2) is not an operating system but rather a flexible framework for writing robot software. It is a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms."),(0,a.yg)("p",null,'In the context of Physical AI, ROS 2 serves as the middleware "nervous system" that connects AI algorithms with physical robot systems. This connection is essential because:'),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Abstraction Layer"),": ROS 2 provides an abstraction layer between AI algorithms and hardware, allowing researchers to focus on algorithm development rather than hardware integration details.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Communication Infrastructure"),": It provides a standardized communication infrastructure that allows different components of a robot system to exchange information seamlessly.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Modularity"),": The modular architecture of ROS 2 enables different teams to work on different components simultaneously, then integrate them into a cohesive system.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Reusability"),": Many components and algorithms developed for ROS 2 can be reused across different robot platforms, accelerating development."))),(0,a.yg)("h2",{id:"ros-2-architecture-overview-nodes-executors-dds"},"ROS 2 Architecture Overview (nodes, executors, DDS)"),(0,a.yg)("p",null,"The ROS 2 architecture is built on the Data Distribution Service (DDS) standard, which provides a publish-subscribe communication model. The key components of the ROS 2 architecture include:"),(0,a.yg)("h3",{id:"nodes"},"Nodes"),(0,a.yg)("p",null,"Nodes are the fundamental building blocks of a ROS 2 system. Each node is a process that performs a specific task and communicates with other nodes through messages. Nodes can be written in different programming languages (C++, Python, etc.) and run on different machines."),(0,a.yg)("p",null,"Key characteristics of nodes:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Each node typically performs a single, specific function"),(0,a.yg)("li",{parentName:"ul"},"Nodes communicate with each other through topics, services, or actions"),(0,a.yg)("li",{parentName:"ul"},"Nodes can be started and stopped independently"),(0,a.yg)("li",{parentName:"ul"},"Multiple nodes can run on the same machine or distributed across multiple machines")),(0,a.yg)("h3",{id:"executors"},"Executors"),(0,a.yg)("p",null,"Executors manage the execution of callbacks from multiple nodes. They determine how and when the callbacks are executed, allowing for different threading models and execution strategies."),(0,a.yg)("p",null,"Types of executors:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Single-threaded executor"),": Executes all callbacks in a single thread"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Multi-threaded executor"),": Distributes callbacks across multiple threads"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Static single-threaded executor"),": Similar to single-threaded but with better performance for static sets of nodes")),(0,a.yg)("h3",{id:"dds-data-distribution-service"},"DDS (Data Distribution Service)"),(0,a.yg)("p",null,"DDS is the middleware that handles message passing between nodes. It provides a standardized way for nodes to communicate with each other, regardless of the programming language or operating system they are using."),(0,a.yg)("p",null,"DDS features:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Discovery"),": Automatically discovers nodes on the network"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Quality of Service (QoS)"),": Configurable parameters that define communication behavior"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Reliability"),": Ensures messages are delivered according to specified requirements"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Durability"),": Can store messages for late-joining nodes")),(0,a.yg)("h2",{id:"why-ros-2-over-ros-1-for-real-time-humanoid-systems"},"Why ROS 2 over ROS 1 for Real-time Humanoid Systems?"),(0,a.yg)("p",null,"ROS 2 offers several advantages over ROS 1, particularly for real-time humanoid systems:"),(0,a.yg)("h3",{id:"improved-real-time-performance"},"Improved Real-time Performance"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"DDS-based communication"),": Provides better real-time performance and determinism compared to ROS 1's custom communication layer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Quality of Service (QoS) settings"),": Allow fine-tuning of communication behavior for real-time requirements"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Better resource management"),": More efficient memory and CPU usage")),(0,a.yg)("h3",{id:"enhanced-security"},"Enhanced Security"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Built-in security features"),": Authentication, encryption, and access control"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Secure communication"),": Protects sensitive robot data and commands")),(0,a.yg)("h3",{id:"better-architecture"},"Better Architecture"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Client Library Independence"),": Language-agnostic design"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Improved build system"),": Uses CMake and colcon for better dependency management"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Lifecycle management"),": Better state management for nodes")),(0,a.yg)("h3",{id:"improved-middleware-support"},"Improved Middleware Support"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Multiple DDS implementations"),": Support for different DDS vendors"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Better integration"),": Easier integration with existing systems")),(0,a.yg)("h2",{id:"how-middleware-enables-embodied-intelligence"},"How Middleware Enables Embodied Intelligence"),(0,a.yg)("p",null,"Middleware like ROS 2 plays a crucial role in enabling embodied intelligence by:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Facilitating Communication"),": Allowing different components of a robot system to communicate seamlessly"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Providing Abstraction"),": Hiding the complexity of hardware and communication details"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Enabling Modularity"),": Allowing different components to be developed and tested independently"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Supporting Integration"),": Making it easier to integrate AI algorithms with physical robot systems")),(0,a.yg)("h3",{id:"the-nervous-system-analogy"},"The Nervous System Analogy"),(0,a.yg)("p",null,"Just as the nervous system in biological organisms connects the brain (AI) with the body (physical robot), middleware like ROS 2 connects AI algorithms with physical robot systems. This connection enables:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Sensory Feedback"),": Information from sensors flows to AI algorithms"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Motor Commands"),": AI decisions are translated into physical actions"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Coordination"),": Multiple subsystems work together harmoniously"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Adaptation"),": The system can respond to changes in the environment")),(0,a.yg)("h2",{id:"summary"},"Summary"),(0,a.yg)("p",null,'This chapter introduced ROS 2 as a middleware "nervous system" for humanoid robots. We covered the core components of ROS 2 architecture and explained why ROS 2 is preferred over ROS 1 for real-time humanoid systems. The next chapter will dive deeper into ROS 2 communication primitives.'),(0,a.yg)("h2",{id:"exercises"},"Exercises"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Research and list three different DDS implementations that can be used with ROS 2."),(0,a.yg)("li",{parentName:"ol"},"Explain the difference between a topic and a service in ROS 2."),(0,a.yg)("li",{parentName:"ol"},"Why is real-time performance important for humanoid robots?")),(0,a.yg)("h2",{id:"references"},"References"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"ROS 2 Documentation: ",(0,a.yg)("a",{parentName:"li",href:"https://docs.ros.org/en/humble/"},"https://docs.ros.org/en/humble/")),(0,a.yg)("li",{parentName:"ol"},"DDS Specification: ",(0,a.yg)("a",{parentName:"li",href:"https://www.omg.org/spec/DDS/"},"https://www.omg.org/spec/DDS/")),(0,a.yg)("li",{parentName:"ol"},"ROS 2 Design: ",(0,a.yg)("a",{parentName:"li",href:"https://design.ros2.org/"},"https://design.ros2.org/"))),(0,a.yg)("h2",{id:"next-steps"},"Next Steps"),(0,a.yg)("p",null,"Continue to ",(0,a.yg)("a",{parentName:"p",href:"/hackathon-1-ai-book/modules/ros2-humanoid/chapter-2-communication/"},"Chapter 2: ROS 2 Communication Primitives")," to learn about communication primitives in ROS 2."),(0,a.yg)("h2",{id:"content-validation"},"Content Validation"),(0,a.yg)("p",null,"This chapter has been written to meet the Flesch-Kincaid grade level 11-13 as required by the project constitution, using clear language, appropriate sentence structure, and technical terminology explained in context."))}d.isMDXComponent=!0},5680(e,t,r){r.d(t,{xA:()=>m,yg:()=>p});var n=r(6540);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach(function(t){a(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},m=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef(function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=c(r),p=a,g=u["".concat(l,".").concat(p)]||u[p]||d[p]||i;return r?n.createElement(g,o(o({ref:t},m),{},{components:r})):n.createElement(g,o({ref:t},m))});function p(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"}}]);